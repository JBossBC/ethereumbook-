# 交易

交易是由外部拥有账户 (EOA) 发起的签名消息，由以太坊网络传输，并记录在以太坊区块链上。这个基本定义隐藏了许多令人惊讶和迷人的细节。另一种看待交易的方式是，它们是唯一可以触发状态更改或导致合约在 EVM 中执行的事物。以太坊是一个全球单例状态机，而交易是使该状态机“滴答作响”并改变其状态的原因。**合约不会自行运行。**以太坊不会自主运行。一切都从交易开始。

在本章中，我们将剖析交易，展示它们如何工作，并检查细节。请注意，本章的大部分内容是针对那些有兴趣在低级别管理自己的交易的人，可能是因为他们正在编写钱包应用程序；如果您喜欢使用现有的钱包应用程序，则不必担心这一点，尽管您可能会发现这些细节很有趣！

## 交易的结构


首先让我们看一下交易的基本结构，因为它是在以太坊网络上序列化和传输的。客户端软件经常添加到交易中的其他元数据包括块号（一旦它被挖掘并包含在区块链中）和交易 ID（计算的哈希值）。每个接收到序列化事务的客户端和应用程序都将使用自己的内部数据结构将其存储在内存中，可能会使用网络序列化事务本身不存在的元数据进行修饰。网络序列化是交易的唯一标准形式。

事务是包含以下数据的序列化二进制消息：

### nonce

由原始 EOA 发布的序列号，用于防止消息重播

### gas price

发起人愿意为每单位气体支付的以太币数量（以 wei 为单位）

### gas limit


发起人愿意为此交易购买的最大 gas 量

### recipient

目标以太坊地址

### Value

发送到目的地的以太币数量（以 wei 为单位）


###  data

可变长度二进制数据有效载荷
 
### v,r,s

原始 EOA 的 ECDSA 数字签名的三个组成部分


交易消息的结构使用递归长度前缀 (RLP) 编码方案进行序列化，该方案专为以太坊中简单、字节完美的数据序列化而创建。以太坊中的所有数字都被编码为大端整数，长度是 8 位的倍数。


请注意，为了清楚起见，此处显示了字段标签（to、gas limit 等），但它们不是交易序列化数据的一部分，交易序列化数据包含 RLP 编码的字段值。通常，RLP 不包含任何字段分隔符或标签。RLP 的长度前缀用于标识每个字段的长度。超出定义长度的任何内容都属于结构中的下一个字段。

虽然这是传输的实际交易结构，但大多数内部表示和用户界面可视化都用来自交易或区块链的附加信息来修饰它。


例如，您可能会注意到地址中没有“发件人”数据来标识发起人 EOA。这是因为 EOA 的公钥可以从 ECDSA 签名的 v,r,s 组件中导出。该地址又可以从公钥中导出。当您看到显示“来自”字段的交易时，这是由用于可视化交易的软件添加的。客户端软件经常添加到交易中的其他元数据包括块号（一旦它被挖掘并包含在区块链中）和交易 ID（计算的哈希值）。同样，此数据源自交易，并不构成交易消息本身的一部分。


## 交易随机数

nonce 是交易中最重要和最不被理解的组成部分之一。黄皮书（参见[参考资料]）中的定义如下：

> nonce:一个标量值，等于从此地址发送的交易数量，或者对于具有关联代码的账户，等于该账户创建的合约数量。


严格来说，nonce是源地址的一个属性；也就是说，它仅在发送地址的上下文中有意义。然而，nonce 并没有作为账户状态的一部分明确存储在区块链上。相反，它是通过计算源自某个地址的已确认交易的数量来动态计算的。

交易计数随机数的存在在两种情况下很重要：交易的可用性特征包含在创建顺序中，以及交易重复保护的重要特征。让我们看一下其中每一个的示例场景：



1. 假设你希望进行两笔交易。您有一笔重要的6ether付款，还有另一笔8ether的付款。你首先签署并广播6ether交易，因为它更重要，然后你签署并广播第二笔8ether交易。可悲的是，您忽略了一个事实，即您的帐户仅包含 10 个以太币，因此网络无法接受两笔交易：其中一笔交易将失败。因为您首先发送了更重要的6ether的一笔交易，所以你可以理解地期望一个通过8ether交易的被拒绝。然而，像以太坊这样的去中心化系统中，节点可能会以任意顺序接收交易;无法保证特定节点会先将一个事务传播到另一个节点。因此，几乎可以肯定的是，一些节点首先接收到6ether交易，而其他节点首先接收刀8个ether交易。如果没有nonce，接受和拒绝哪个将是随机的。但是，如果包含 nonce，您发送的第一笔交易的 nonce 将是 3，而 8-ether 交易具有下一个 nonce 值（即 4）。因此，该交易将被忽略，直到随机数从 0 到 3 的交易被处理，即使它是第一个收到的。
2. 现在你想象你有一个100ether的账户。你在网上找到一个人，他会接收以太币支付你真正想买的mcguffin-widget。您向他们发送2个以太币，他们向您发送mcguffin-widget。为了支付两个以太币，您签署勒一项交易，将2个以太币从您的账户发送到他们的账户，然后将其广播到以太坊网络以进行验证并包含在区块链中。现在，如果交易中没有 nonce 值，第二笔交易第二次向同一地址发送 2 个以太币看起来与第一笔交易完全相同。这意味着任何在以太坊网络上看到您的交易的人（这意味着每个人，包括收件人或敌人）都可以一次又一次地“重播”交易将其重新发送到网络。然而，由于交易数据中包含随机数，每笔交易都是唯一的，即使多次向同一接收地址发送相同数量的以太币也是如此。因此，通过将递增的随机数作为交易的一部分，任何人都不可能“复制”您所做的付款。

总之，重要的是要注意，与比特币协议的“未花费交易输出”（UTXO）机制相比，随机数的使用对于基于帐户的协议实际上至关重要。


### 跟踪随机数

实际上，nonce 是来自一个账户的已确认（即链上）交易数量的最新计数。要找出 nonce 是什么，您可以查询区块链，例如通过 web3 接口。在 Ropsten 测试网上的 Geth（或您首选的 web3 界面）中打开一个 JavaScript 控制台，然后输入：

    web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
    40

> 注意:nonce是一个从零开始的计数器，这意味着第一笔交易的nonce为0，在这个例子中，我们有一个40的交易技术，这意味着已经看到了0-39的随机数，下一笔交易的随机数需要是40.


您的钱包将跟踪它管理的每个地址的随机数。只要您只从一个点发起交易，这样做就相当简单。假设您正在编写自己的钱包软件或发起交易的其他应用程序。你如何跟踪随机数？

当您创建新交易时，您分配序列中的下一个随机数。但在确认之前，它不会计入 getTransactionCount 总数。

> 使用 getTransactionCount 函数计算未决交易时要小心，因为如果您连续发送几笔交易，您可能会遇到一些问题。

让我们看一个例子:

      > web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
      "pending")
       40
      > web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
      "0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
      > web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
      "pending")
      41
     > web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
     "0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
     > web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
     "pending")
     41
    > web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
    "0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34", value: web3.utils.toWei(0.01, "ether")});
    > web3.eth.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f", \
    "pending")
    41


如果您尝试在 Geth 的 javascript 控制台中自己重新创建这些代码示例，您应该使用 web3.toWei() 而不是 web3.utils.toWei()。这是因为 Geth 使用了旧版本的 web3 库。


如您所见，我们发送的第一笔交易将交易计数增加到 41，显示待处理交易。但是，当我们快速连续发送另外三个交易时，getTransactionCount 调用并没有计算它们。它只计算了一个，即使你可能认为内存池中有三个待处理。如果我们等待几秒钟以允许网络通信稳定下来，则 getTransactionCount 调用将返回预期的数字。但在此期间，虽然有不止一笔交易待处理，但它可能对我们没有帮助。

当您构建一个构造事务的应用程序时，它不能依赖 getTransactionCount 来处理未决事务。只有当待处理和已确认的计数相等时（所有未完成的交易都已确认），您才能相信 getTransactionCount 的输出来启动您的随机数计数器。此后，在您的应用程序中跟踪随机数，直到每笔交易都得到确认。


Parity 的 JSON RPC 接口提供了 parity_nextNonce 函数，它返回应该在交易中使用的下一个随机数。parity_nextNonce 函数会正确计算随机数，即使您在没有确认的情况下快速连续构建多个交易：


     $ curl --data '{"method":"parity_nextNonce", \
      "params":["0x9e713963a92c02317a681b9bb3065a8249de124f"],\
      "id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST \
      localhost:8545

      {"jsonrpc":"2.0","result":"0x32","id":1}


> 注意: Parity 有一个用于访问 JSON RPC 接口的 Web 控制台，但这里我们使用命令行 HTTP 客户端来访问它。


### Nonce 中的间隙、重复的 Nonce 和确认


如果您以编程方式创建交易，那么跟踪随机数很重要，尤其是当您同时从多个独立进程这样做时。

以太坊网络根据随机数顺序处理交易。这意味着如果您传输一个随机数为 0 的交易，然后传输一个随机数为 2 的交易，则第二个交易将不会包含在任何块中。它将存储在内存池中，而以太坊网络等待丢失的随机数出现。所有节点都假设丢失的随机数只是被延迟了，并且随机数为 2 的交易是乱序接收的。

如果您随后传输缺少随机数 1 的交易，则将处理并包括两个交易（随机数 1 和 2）（当然，如果有效）。一旦填补了空白，网络就可以挖掘它在内存池中保存的乱序交易。


这意味着，如果您按顺序创建多个交易，而其中一个没有正式包含在任何区块中，则所有后续交易都将“停滞”，等待丢失的随机数。一笔交易可能会在 nonce 序列中产生一个无意的“间隙”，因为它是无效的或没有足够的 gas。为了让事情再次发生，你必须传输一个带有缺失随机数的有效交易。您应该同样注意，一旦网络验证了带有“缺失”随机数的交易，所有带有后续随机数的广播交易将逐渐变得有效；不可能“召回”交易！

另一方面，如果您不小心复制了一个 nonce，例如通过传输两个具有相同 nonce 但不同接收者或值的交易，那么其中一个将被确认而另一个将被拒绝。哪一个被确认将取决于它们到达第一个接收它们的验证节点的顺序——也就是说，这将是相当随机的。

如您所见，跟踪随机数是必要的，如果您的应用程序没有正确管理该过程，您将会遇到问题。不幸的是，如果您尝试同时执行此操作，事情会变得更加困难，正如我们将在下一节中看到的那样。


### 并发，事务发起和随机数


并发是计算机科学的一个复杂方面，它有时会出乎意料地出现，尤其是在像以太坊这样的去中心化和分布式实时系统中。

简单来说，并发就是多个独立系统同时进行计算。它们可以在同一个程序中（例如，多线程），在同一个 CPU 上（例如，多处理），或者在不同的计算机上（例如，分布式系统）。根据定义，以太坊是一个允许并发操作（节点、客户端、DApps）但通过共识强制执行单例状态的系统。

现在，假设您有多个独立的钱包应用程序，它们从同一个地址或多个地址生成交易。这种情况的一个例子是交易所处理从交易所的热钱包（密钥存储在网上的钱包，与密钥从不在线的冷钱包形成对比）的提款。理想情况下，您希望有不止一台计算机处理取款，这样它就不会成为瓶颈或单点故障。然而，这很快就会成为问题，因为有多台计算机产生取款会导致一些棘手的并发问题，其中最重要的是随机数的选择。多台计算机如何协调从同一个热钱包帐户生成、签名和广播交易？


您可以使用一台计算机按照先到先得的原则将随机数分配给签署交易的计算机。但是，这台计算机现在是单点故障。更糟糕的是，如果分配了多个随机数，但其中一个从未被使用过（因为使用该随机数处理交易的计算机出现故障），所有后续交易都会陷入困境。


另一种方法是生成交易，但不为它们分配随机数（因此让它们未签名——记住随机数是交易数据的组成部分，因此需要包含在验证交易的数字签名中） .然后，您可以将它们排队到一个节点，该节点对它们进行签名并跟踪随机数。不过，这再次成为流程中的瓶颈：随机数的签名和跟踪是您操作中可能在负载下变得拥塞的部分，而未签名交易的生成是您真正不需要的部分需要并行化。你会有一些并发性，但在过程的关键部分会缺乏它。


最后，这些并发问题，加上在独立进程中跟踪账户余额和交易确认的困难，迫使大多数实现避免并发和产生瓶颈，例如单个进程处理交易所中的所有取款交易，或设置多个可以完全独立进行提款的热钱包，只需要间歇性地重新平衡。


## 交易gas

我们在前面的章节中略微谈到了 gas，我们在 [gas] 中更详细地讨论了它。价格以每瓦斯单位 wei 为单位。但是，让我们介绍一些关于交易的 gasPrice 和 gasLimit 组件的作用的基础知识。

Gas 是以太坊的燃料。Gas 不是以太币——它是一种独立的虚拟货币，对以太币有自己的汇率。以太坊使用 gas 来控制交易可以使用的资源量，因为它将在全球数千台计算机上进行处理。开放式（图灵完备）计算模型需要某种形式的计量，以避免拒绝服务攻击或无意中消耗资源的交易。



Gas 与 Ether 是分开的，以保护系统免受随着 Ether 价值的快速变化而可能出现的波动的影响，同时也是一种管理 Gas 支付的各种资源成本之间重要和敏感​​比率的方法（即计算、记忆和存储）。

交易中的gasPrice字段允许交易发起者设置他们愿意支付的价格以换取gas。价格以每瓦斯单位 wei 为单位。例如，在 [intro_chapter] 的示例交易中，您的钱包将 gasPrice 设置为 3 gwei（3 gigawei 或 30 亿 wei）。   














