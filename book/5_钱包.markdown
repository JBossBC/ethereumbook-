# 钱包

“钱包”一词用于描述以太坊中的一些不同事物。

在高层次上，钱包是一种软件应用程序，作为以太坊的主要用户界面。钱包控制对用户资金的访问、管理密钥和地址、跟踪余额以及创建和签署交易。此外，一些以太坊钱包也可以与合约进行交互，例如ERC20代币。

更狭义地说，从程序员的角度来看，钱包一词是指用于存储和管理用户密钥的系统。每个钱包都有一个密钥管理组件。对于某些钱包，仅此而已。其他钱包属于更广泛类别的一部分，即浏览器，它们是基于以太坊的去中心化应用程序或 DApp 的接口，我们将在 [去中心化应用程序章节] 中更详细地研究它们。在术语钱包下合并的各种类别之间没有明确的区别。

在本章中，我们将钱包视为私钥的容器，以及管理这些私钥的系统。


## 钱包技术概述


在本节中，我们总结了用于构建用户友好、安全和灵活的以太坊钱包的各种技术。

设计钱包的一个关键考虑因素是平衡便利性和隐私性。最方便的以太坊钱包是一个只有一个私钥和地址的钱包，您可以重复使用它来处理所有事情。不幸的是，这样的解决方案是一场隐私噩梦，因为任何人都可以轻松跟踪和关联您的所有交易。为每笔交易使用新密钥最有利于保护隐私，但变得非常难以管理。很难达到正确的平衡，但这就是为什么好的钱包设计至关重要。

关于以太坊的一个常见误解是以太坊钱包包含以太币或代币。事实上，非常严格地说，**钱包只装钥匙。以太币或其他代币记录在以太坊区块链上。**用户通过使用钱包中的密钥签署交易来控制网络上的代币。从某种意义上说，以太坊钱包是一个钥匙串。话虽如此，鉴于钱包持有的密钥是将以太币或代币转移给他人所需的唯一东西，实际上这种区别是无关紧要的。真正重要的区别在于改变处理传统银行中心化系统的思维方式（只有你和银行才能看到你账户中的钱，你只需要说服银行你想将资金转移到进行交易）到区块链平台的去中心化系统（每个人都可以看到账户的以太币余额，尽管他们可能不知道账户的所有者，并且每个人都需要确信所有者想要将资金转移到颁布）。在实践中，这意味着有一种独立的方式来检查账户的余额，而不需要它的钱包。此外，如果您开始不喜欢开始使用的钱包应用程序，您可以将您的帐户处理从当前钱包转移到另一个钱包。


> 注意:以太坊钱包包含密钥，而不是以太币或代币。钱包就像包含一对私钥和公钥的钥匙串。用户使用私钥签署交易，从而证明他们拥有以太币。ether存储在区块链上。


有两种主要类型的钱包，根据它们包含的密钥是否相互关联来区分。

第一种是非确定性钱包，其中每个密钥都是从不同的随机数独立生成的。键彼此不相关。这种类型的钱包也被称为 JBOK 钱包，来自短语“Just a Bunch of Keys”。

第二种类型的钱包是确定性钱包，其中所有密钥都来自一个主密钥，称为种子。这类钱包中的所有密钥都是相互关联的，如果有原始种子，可以重新生成。确定性钱包中使用了许多不同的密钥派生方法。最常用的推导方法使用树状结构，如分层确定性钱包 (BIP-32/BIP-44) 中所述。

为了使确定性钱包稍微更安全地防止数据丢失事故，例如手机被盗或掉进马桶，种子通常被编码为单词列表（英语或其他语言）供您写下和使用万一发生事故。这些被称为钱包的助记码字。当然，如果有人拿到了你的助记词，那么他们也可以重新创建你的钱包，从而获得你的以太币和智能合约。因此，要非常非常小心你的恢复词列表！切勿将其以电子方式存储在文件中、计算机或手机上。将其写在纸上并将其存放在安全可靠的地方。

接下来的几节将在较高层次上介绍这些技术中的每一项。


## 非确定性（随机）钱包

在第一个以太坊钱包（为以太坊预售而制作）中，每个钱包文件都存储了一个随机生成的私钥。此类钱包正在被确定性钱包取代，因为这些“老式”钱包在很多方面都不如人意。例如，在使用以太坊时，避免重复使用以太坊地址作为最大化隐私的一部分被认为是一种很好的做法——即，每次收到资金时使用一个新地址（需要一个新的私钥）。你可以更进一步，为每笔交易使用一个新地址，尽管如果你处理大量代币，这可能会变得昂贵。为了遵循这种做法，非确定性钱包将需要定期增加其密钥列表，这意味着您将需要进行定期备份。如果您在成功备份钱包之前丢失了数据（磁盘故障、酒后事故、手机被盗），您将无法访问您的资金和智能合约。 “0 型”非确定性钱包是最难处理的，因为它们以“及时”的方式为每个新地址创建一个新的钱包文件。

然而，许多以太坊客户端（包括 geth）使用密钥库文件，这是一个 JSON 编码的文件，包含一个（随机生成的）私钥，并通过密码加密以提高安全性。 JSON 文件的内容如下所示：

    {
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
    }

密钥库格式使用密钥派生函数 (KDF)，也称为密码拉伸算法，可防止暴力攻击、字典攻击和彩虹表攻击。简单来说，私钥不是直接用passphrase加密的。取而代之的是，通过反复散列来扩展密码。哈希函数重复 262,144 轮，这可以在密钥库 JSON 中作为参数 crypto.kdfparams.n 看到。试图暴力破解密码短语的攻击者必须对每个尝试的密码短语应用 262,144 轮散列，这会充分减慢攻击速度，使其无法用于具有足够复杂性和长度的密码短语。

> 除了简单测试之外，不鼓励使用非确定性钱包。除了最基本的情况外，它们太笨重而无法备份和使用。相反，使用基于行业标准的 HD 钱包和助记词种子进行备份。


## 确定性（种子）钱包


确定性或“种子”钱包是包含私钥的钱包，这些私钥均源自单个主密钥或种子。种子是一个随机生成的数字，它与其他数据相结合，例如索引号或“链码”（请参阅​​扩展公钥和私钥），以派生出任意数量的私钥。在确定性钱包中，种子足以恢复所有派生密钥，因此在创建时的单个备份足以保护钱包中的所有资金和智能合约。种子也足以用于钱包导出或导入，允许在不同钱包实现之间轻松迁移所有密钥。

这种设计使种子的安全性变得至关重要，因为只需要种子就可以访问整个钱包。另一方面，能够将安全工作集中在单个数据上可以被视为一种优势。


### 分层确定性钱包 (BIP-32/BIP-44)


开发确定性钱包是为了方便从单个种子中导出许多密钥。目前，最先进的确定性钱包形式是比特币 BIP-32 标准定义的分层确定性 (HD) 钱包。 HD 钱包包含以树结构派生的密钥，这样父密钥可以派生出一系列子密钥，每个子密钥都可以派生出一系列孙密钥，依此类推。这种树结构在 HD 钱包中有说明：从单个种子生成的密钥树。

### 种子和助记码（BIP-39）


有许多方法可以对私钥进行编码以实现安全备份和检索。目前首选的方法是使用一系列单词，当这些单词以正确的顺序组合在一起时，可以唯一地重新创建私钥。这有时被称为助记符，并且该方法已由 BIP-39 标准化。今天，许多以太坊钱包（以及其他加密货币的钱包）都使用这个标准，并且可以使用可互操作的助记符导入和导出种子以进行备份和恢复。

要了解为什么这种方法变得流行，让我们看一个例子：

确定性钱包的种子，十六进制

> FCCF1AB3329FD5DA3DA9577511F8F137

一个确定性钱包的种子，来自一个12字的助记词

> wolf juice proud gown wool unfair
> 
>wall cliff insect more detail hub


实际上，写下十六进制序列时出错的可能性高得令人无法接受。相比之下，known words列表就相当好处理了，主要是因为单词（尤其是英文单词）的书写冗余度很高。如果不小心记录了“inzect”，则可以根据钱包恢复的需要快速确定“inzect”不是有效的英文单词，应该使用“insect”代替。我们正在谈论写下种子的表示，因为这是管理 HD 钱包的好习惯：在数据丢失（无论是由于意外还是被盗）的情况下，需要种子来恢复钱包，因此保留备份是非常谨慎的.但是，种子必须非常保密，因此应小心避免数字备份；因此，较早的建议是用笔和纸进行备份。

综上所述，使用恢复词列表对HD钱包种子进行编码，是安全导出、转录、记录在纸上、无误读取以及将私钥集导入另一个钱包的最简单方法。


## 钱包最佳实践


随着加密货币钱包技术的成熟，出现了某些通用的行业标准，使钱包具有广泛的互操作性、易于使用、安全和灵活。这些标准还允许钱包从单个助记符中导出多种不同加密货币的密钥。这些通用标准是：


+ 助记词，基于BIP-39
+ HD钱包，基于BIP-32
+ 多用途HD钱包结构，基于BIP-43
+ 基于 BIP-44 的多币种和多账户钱包

这些标准可能会随着未来的发展而改变或被淘汰，但目前它们形成了一套相互关联的技术，这些技术已成为大多数区块链平台及其加密货币的事实上的钱包标准。

这些标准已被广泛的软件和硬件钱包采用，使所有这些钱包都可以互操作。用户可以导出在其中一个钱包中生成的助记词，并将其导入到另一个钱包中，从而恢复所有密钥和地址。

支持这些标准的一些软件钱包示例包括（按字母顺序列出）Jaxx、MetaMask、MyCrypto 和 MyEtherWallet (MEW)。支持这些标准的硬件钱包示例包括 Keepkey、Ledger 和 Trezor。

以下各节将详细研究这些技术中的每一项。

> 提示:如果你正在使用以太坊钱包，则应该将其构建为HD钱包，种子编码为助记词提供备份，遵循BIP-32、BIP-39、BIP43、和BIP44标准，如所述在以下部分。

### 助记词(BIP-39)

助记词是对随机数进行编码的单词序列，该随机数用作派生确定性钱包的种子。单词序列足以重新创建种子，并从那里重新创建钱包和所有派生密钥。使用助记词实现确定性钱包的钱包应用程序将在首次创建钱包时向用户显示 12 到 24 个单词的序列。该单词序列是钱包备份，可用于恢复和重新创建相同或任何兼容钱包应用程序中的所有密钥。正如我们之前解释的那样，助记词列表使用户更容易备份钱包，因为它们易于阅读和正确转录。

> 注意:助记词经常与“brainwallets”混淆。他们不一样。主要区别在于脑钱包由用户选择的单词组成，而助记词是由钱包随机创建并呈现给用户的。这个重要的区别使得助记词更加安全，因为人类是非常差的随机性来源。或许更重要的是，使用“brainwallets”一词意味着必须记住这些单词，这是一个糟糕的想法，也是在需要时没有备份的秘诀。


助词在 BIP-39 中定义。请注意，BIP-39 是助记词标准的一种实现。 Electrum 比特币钱包使用不同的标准，使用不同的词组，早于 BIP-39。 BIP-39 是由 Trezor 硬件钱包背后的公司提出的，与 Electrum 的实施不兼容。然而，BIP-39 现在已经在数十个可互操作的实现中获得了广泛的行业支持，应该被视为事实上的行业标准。此外，BIP-39 可用于生产支持以太坊的多币种钱包，而 Electrum 种子则不能。


BIP-39 定义了助记词和种子的创建，我们在这里分九个步骤进行描述。为清楚起见，该过程分为两部分：步骤 1 到 6 显示在生成助记词中，步骤 7 到 9 显示在从助记符到种子中。


### 生成助记词

助记词由钱包使用 BIP-39 中定义的标准化流程自动生成。钱包从熵源开始，添加校验和，然后将熵映射到单词列表：


+ 创建 128 到 256 位的加密随机序列 S。
+ 通过取 S 的第一个长度 ÷ S 的 SHA-256 散列的 32 位来创建 S 的校验和。
+ 将校验和添加到随机序列 S 的末尾。
+ 将序列和校验和串联分成 11 位的部分。
+ 将每个 11 位值映射到包含 2,048 个单词的预定义字典中的一个单词。
+ 从单词序列创建助记码，保持顺序。


生成熵和编码为助记词展示了如何使用熵来生成助记词。

助记词：熵与词长表示熵数据的大小与词中助记码长度的关系。

表1.助记词：熵和字长

|熵|校验和|熵+校验和|助记词长度|
|--|--|--|--|
|128|4|132|12|
|160|5|165|15|
|192|6|198|18|
|224|7|231|21|

![图2](https://github.com/JBossBC/ethereumbook-ch/blob/main/book/images/bip39-part1.png?raw=true)

图2.生成熵并编码为助记词

### 从助记词到种子

助记词表示熵，长度为128位到256位，然后，通过使用密钥扩展函数PBKDF2,使用熵来导出更长的512位种子，产生的种子用于构建确定性钱包并派生其密钥。

密钥扩展有两个参数:助记词和salt。密钥扩展函数中加盐的目的是使构建支持暴力攻击的查找表变得困难。在BIP-39标准中，salt还有另一个目的:它允许引入一个密码短语，作为保护种子的额外安全因素，我们将在BIP-39中的可选密码短语中更详细地描述

步骤7到9中描述的过程从上一节中描述的过程继续:

+ PBKDF2密钥拉伸函数的第一个参数是在步骤6中生成助记词。
+ PBKDF2密钥扩展函数的第二个参数是salt。salt由字符串常量"mnemonic"和可选的用户提供的密码组成。
+ PBKDF2使用HMAC-SHA512算法使用2048轮散列来扩展助记词和salt参数，产生512位值作为其最终输出。这个512位的值就是种子。


从助记词到种子展示了如何使用助记符生成种子。


！[图3](https://github.com/JBossBC/ethereumbook-ch/blob/main/book/images/bip39-part2.png?raw=true)

图3.从助记词到种子

> 注意： 具有2048轮散列的密钥扩展功能在某种程度上可以有效地防止针对助记词或密码的暴力攻击。尝试超过几千个密码短语和助记词组合的成本很高(在计算中)，而可能派生的种子数量很大(2^512,或大约10^154）--远远大于可见宇宙中的原子数量(大约10^80)


下表显示了助记词及其产生的种子的一些示例。

表2.128 位熵助记码，无密码，生成的种子

|熵输入(128位)|0c1e24e5917779d297e14d45f14e1a1a|
|--|--|
|助记词(12个词)|a rmy van defense carry jealous true garbage claim echo media make crunch|
|短语|(none)|
|种子(512位)|5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4c67196f57c39 a88b76373733891bfaba16ed27a813ceed498804c0570|










