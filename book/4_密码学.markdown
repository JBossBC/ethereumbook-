# 密码学

以太坊的一项基础技术是密码学，它是广泛用于计算机安全的数学分支。密码学在希腊语中的意思是“秘密书写”，但密码学的研究不仅仅包括秘密书写，也就是所谓的加密。例如，密码学也可用于在不泄露秘密的情况下证明知道秘密（例如，使用数字签名），或证明数据的真实性（例如，使用数字指纹，也称为“散列”）。这些类型的密码证明是对以太坊平台（以及所有区块链系统）的运行至关重要的数学工具，并且也广泛用于以太坊应用程序中。

请注意，在发布时，以太坊协议的任何部分都没有涉及加密；也就是说，与以太坊平台和节点之间的所有通信（包括交易数据）都是未加密的，任何人都可以（必须）读取。这样每个人都可以验证状态更新的正确性并达成共识。未来会出现零知识证明、同态加密等先进的密码学工具，允许将一些加密计算记录在区块链上，同时仍能达成共识；然而，虽然已经为他们做好准备，但他们尚未部署。

在本章中，我们将介绍以太坊中使用的一些密码学：即公钥密码学（PKC），它用于以私钥和地址的形式控制资金的所有权。


## 密钥和地址


正如我们在本书前面看到的，以太坊有两种不同类型的账户：外部拥有账户（EOA）和合约。 EOA 对以太币的所有权是通过数字私钥、以太坊地址和数字签名建立的。私钥是所有用户与以太坊交互的核心。事实上，账户地址是直接从私钥推导出来的：一个私钥唯一确定一个单一的以太坊地址，也称为账户。

私钥不以任何方式直接在以太坊系统中使用；它们永远不会传输或存储在以太坊上。也就是说，私钥应该保持私密，绝不会出现在传递给网络的消息中，也不应该存储在链上；只有帐户地址和数字签名会在以太坊系统上传输和存储。

资金的访问和控制是通过数字签名实现的，数字签名也是使用私钥创建的。以太坊交易需要有效的数字签名才能包含在区块链中。任何拥有私钥副本的人都可以控制相应的帐户及其持有的任何以太币。假设用户保护他们的私钥安全，以太坊交易中的数字签名证明了资金的真正所有者，因为它们证明了私钥的所有权。

在基于公钥加密的系统中，例如以太坊使用的系统，密钥成对出现，由私钥和公钥组成。把公钥想象成一个银行账号，把私钥想象成一个密码；后者提供对帐户的控制，前者向其他人识别帐户。私钥本身很少被以太坊用户看到；大多数情况下，它们存储（以加密形式）在特殊文件中并由以太坊钱包软件管理。

在以太坊交易的支付部分，预期的收款人由以太坊地址表示，其使用方式与银行转账的收款人账户详细信息相同。正如我们稍后将更详细地看到的，EOA 的以太坊地址是从密钥对的公钥部分生成的。然而，并不是所有的以太坊地址都代表公钥-私钥对；它们还可以表示合约，正如我们将在 [智能合约章节] 中看到的那样，合约不受私钥支持。

在本章的其余部分，我们将首先更详细地探讨基本密码学，并解释以太坊中使用的数学。然后我们将看看密钥是如何生成、存储和管理的。最后，我们将回顾用于表示私钥、公钥和地址的各种编码格式。

## 公钥密码学和加密货币


公钥加密（也称为“非对称密码”）是现代信息安全的核心部分。密钥交换协议于 1970 年代由 Martin Hellman、Whitfield Diffie 和 Ralph Merkle 首次发布，是一项巨大的突破，引发了密码学领域的第一波公众兴趣。在 20 世纪 70 年代之前，强大的密码学知识被政府保密。

公钥密码术使用唯一密钥来保护信息。这些密钥基于具有特殊属性的数学函数：计算它们很容易，但很难计算它们的反函数。基于这些功能，密码学可以创建数字秘密和不可伪造的数字签名，这些数字秘密和不可伪造的数字签名受到数学定律的保护。

例如，将两个大质数相乘是微不足道的。但是给定两个大质数的乘积，很难找到质因数（称为质因数分解的问题）。假设我们给出数字 8,018,009 并告诉您它是两个素数的乘积。找到这两个质数对你来说比我将它们相乘得到 8,018,009 困难得多。

如果您知道一些秘密信息，其中一些数学函数可以很容易地反转。在前面的示例中，如果我告诉您其中一个质因数是 2,003，您可以通过简单的除法轻松找到另一个质因数：8,018,009 ÷ 2,003 = 4,003。这样的函数通常被称为陷门函数，因为它们很难反转，除非你得到一条可以用作反转函数的捷径的秘密信息。

在密码学中有用的一类更高级的数学函数基于椭圆曲线上的算术运算。在椭圆曲线算术中，素数模乘法很简单，但除法（逆运算）实际上是不可能的。这称为离散对数问题，目前还没有已知的陷门。椭圆曲线密码术在现代计算机系统中得到广泛使用，是以太坊（和其他加密货币）使用私钥和数字签名的基础。

> 注意:如果您有兴趣阅读更多有关密码学和现代密码学中使用的数学函数的信息，请查看以下资源：

>  + [Cryptography](https://en.wikipedia.org/wiki/Cryptography)
>  + [Trapdoor function](https://en.wikipedia.org/wiki/Trapdoor_function)
>  + [Prime factorization](https://en.wikipedia.org/wiki/Integer_factorization)
>  + [Discrete logarithm](https://en.wikipedia.org/wiki/Discrete_logarithm)
>  + [Elliptic curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)


在以太坊中，我们使用公钥密码（也称为非对称密码）来创建我们在本章中一直在讨论的公钥-私钥对。它们被认为是“一对”，因为公钥是从私钥派生出来的。它们共同代表一个以太坊帐户，分别提供一个可公开访问的帐户句柄（地址）和对帐户中任何以太币的访问权限以及使用智能合约时帐户所需的任何身份验证的私人控制。私钥通过作为创建数字签名所需的唯一信息来控制访问，数字签名需要签名交易才能花费帐户中的任何资金。正如我们将在 [智能合约章节] 中看到的那样，数字签名还用于验证合约的所有者或用户。

> 注意: 在大多数钱包实现中，为方便起见，私钥和公钥作为密钥对存储在一起。然而，公钥可以从私钥简单地计算出来，所以只存储私钥也是可能的。


可以创建数字签名来签署任何消息。对于以太坊交易，交易本身的细节被用作消息。密码学的数学——在这种情况下，椭圆曲线密码学——提供了一种将消息（即交易细节）与私钥结合起来以创建只能在知道私钥的情况下生成的代码的方法。该代码称为数字签名。请注意，以太坊交易基本上是访问具有特定以太坊地址的特定帐户的请求。当交易被发送到以太坊网络以转移资金或与智能合约交互时，它需要使用与相关以太坊地址对应的私钥创建的数字签名发送。椭圆曲线数学意味着任何人都可以通过检查数字签名是否与交易细节和请求访问的以太坊地址相匹配来验证交易是否有效。验证完全不涉及私钥；那仍然是私人的。然而，验证过程毫无疑问地确定交易只能来自拥有与以太坊地址背后的公钥相对应的私钥的人。这就是公钥密码学的“魔力”。

> 注意:作为以太坊协议的一部分，没有加密——作为以太坊网络运行的一部分发送的所有消息都可以（必须）被所有人读取。因此，私钥仅用于为交易认证创建数字签名。

## 私钥

私钥只是一个随机选择的数字。私钥的所有权和控制权是用户控制与相应以太坊地址关联的所有资金以及访问授权该地址的合约的根源。私钥用于通过证明交易中使用的资金的所有权来创建花费以太币所需的签名。私钥必须始终保密，因为将其透露给第三方等同于让他们控制由该私钥保护的以太币和合约。私钥也必须备份，防止意外丢失。如果它丢失了，它就无法恢复，它所担保的资金也将永远丢失。

> 注意:以太坊私钥只是一个数字。随机选择私钥的一种方法是简单地使用硬币、铅笔和纸：抛硬币 256 次，您将获得可以在以太坊钱包中使用的随机私钥的二进制数字（可能——请参阅下一节).然后可以从私钥生成公钥和地址。


### 私钥的生成来源于随机数


生成密钥的第一步也是最重要的一步是找到一个安全的熵或随机源。创建以太坊私钥基本上涉及在 1 到 2^256 之间选择一个数字。只要它不可预测或确定，您用来选择该数字的确切方法并不重要。以太坊软件使用底层操作系统的随机数生成器来生成 256 个随机位。通常，操作系统随机数生成器由人为随机源初始化，这就是为什么您可能会被要求摆动鼠标几秒钟，或按键盘上的随机键。另一种可能是计算机麦克风通道上的宇宙辐射噪声。

更准确地说，私钥可以是任何非零数字，直到略小于 2^256 的非常大的数字——一个巨大的 78 位数字，大约为 1.158 * 1077。确切的数字与 2^256 共享前 38 位，并定义为顺序以太坊中使用的椭圆曲线（参见椭圆曲线密码学解释）。为了创建私钥，我们随机选择一个 256 位数字并检查它是否在有效范围内。在编程术语中，这通常是通过将更大的随机位串（从加密安全随机源收集的）馈入 256 位哈希算法（例如 Keccak-256 或 SHA-256）来实现的，这两种算法都可以方便地生成一个 256 位的数字。如果结果在有效范围内，我们就有了合适的私钥。否则，我们只需使用另一个随机数再试一次。


> 提示:2^256——以太坊私钥空间的大小——是一个深不可测的大数字。十进制约为 10^^77；也就是说，一个有 77 位数字的数字。相比之下，可见宇宙估计包含 10^77 到 10^80 个原子。因此，在较低的范围内，有足够的私钥为宇宙中的每个原子提供一个以太坊帐户。如果您随机选择一个私钥，那么任何人都不可能猜到或自己选择。


请注意，私钥生成过程是离线的；它不需要与以太坊网络进行任何通信，甚至不需要与任何人进行任何通信。因此，为了选择一个其他人永远不会选择的数字，它需要是真正随机的。如果您自己选择数字，那么其他人尝试（然后用您的以太币逃跑）的可能性就太高了。使用错误的随机数生成器（如大多数编程语言中的伪随机随机函数）更糟糕，因为它更明显，更容易复制。就像在线帐户的密码一样，私钥需要是不可猜测的。幸运的是，你永远不需要记住你的私钥，所以你可以采取最好的方法来挑选它：即真正的随机性。

>注意:不要编写自己的代码来创建随机数或使用您的编程语言提供的“简单”随机数生成器。使用加密安全的伪随机数生成器（例如 CSPRNG）以及来自足够熵源的种子至关重要。研究您选择的随机数生成器库的文档，以确保它是加密安全的。正确实施 CSPRNG 库对于密钥的安全性至关重要。

下面是一个随机生成的私钥，用十六进制表示（256位表示为64位十六进制数，每4位）：

> f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315

## 公钥

以太坊公钥是椭圆曲线上的一个点，这意味着它是一组满足椭圆曲线方程的 x 和 y 坐标。

简单来说，以太坊公钥是两个数字连接在一起。这些数字是通过只能进行单向计算的私钥产生的。这意味着如果你有私钥，计算公钥是微不足道的，但你不能从公钥计算私钥。

>注意:数学即将到来！不要恐慌。如果您在以下段落中的任何一点开始迷路，您可以跳过接下来的几节。有许多工具和库可以为您计算。

公钥是使用椭圆曲线乘法从私钥计算出来的，这实际上是不可逆的：K = k * G，其中 k 是私钥，G 是称为生成点的常数点，K 是生成的公钥，并且* 是特殊的椭圆曲线“乘法”运算符。请注意，椭圆曲线乘法与普通乘法不同。它与普通乘法共享功能属性，仅此而已。例如，称为“求离散对数”的反向运算（对正态数进行除法）——即，如果知道 K 就计算 k——与尝试所有可能的 k 值一样困难（暴力搜索这可能需要比这个宇宙允许的更多的时间）。

简单来说：椭圆曲线上的算术不同于“常规”整数算术。一个点 (G) 可以乘以一个整数 (k) 以产生另一个点 (K)。但是没有除法这个东西，所以不能简单的把公钥K除以点G来计算私钥k。这是 Public Key Cryptography and Cryptocurrency 中描述的单向数学函数。

> 注意:椭圆曲线乘法是一种被密码学家称为“单向”函数的函数：在一个方向（乘法）很容易做到，而在相反的方向（除法）则不可能做到。私钥的拥有者可以轻松创建公钥，然后与全世界共享，因为知道没有人可以反转函数并从公钥计算出私钥。这个数学技巧成为不可伪造和安全的数字签名的基础，证明以太坊资金的所有权和合同的控制权。


在我们演示如何从私钥生成公钥之前，让我们更详细地了解一下椭圆曲线密码学。

### 椭圆曲线密码学解释

椭圆曲线密码术是一种基于离散对数问题的非对称或公钥密码术，由椭圆曲线点上的加法和乘法表示。

椭圆曲线的可视化是椭圆曲线的一个例子，类似于以太坊使用的。

> 注意:以太坊使用与比特币完全相同的椭圆曲线，称为 secp256k1。这使得重用比特币的许多椭圆曲线库和工具成为可能。

![图1](https://github.com/JBossBC/ethereumbook-ch/blob/main/book/images/simple_elliptic_curve.png?raw=true)


图 1. 椭圆曲线的可视化
以太坊使用特定的椭圆曲线和一组数学常数，正如美国国家标准与技术研究院 (NIST) 建立的名为 secp256k1 的标准中所定义的那样。 secp256k1 曲线由以下函数定义，该函数生成椭圆曲线：

y 2 = ( x 3 + 7 ) 在 ( 𝔽 p )
或者：

y 2 mod p = ( x 3 + 7 ) mod p
mod p（模素数 p）表示该曲线在素数阶 p 的有限域上，也写为 (( mathbb{F}_p ))，其中 p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1，这是一个非常大的素数。


因为这条曲线是在素数阶的有限域上定义的，而不是在实数上定义的，所以它看起来像散布在二维中的点图案，这使得它很难形象化。但是，数学与实数上的椭圆曲线的数学相同。例如，椭圆曲线密码学：可视化 F(p) 上的椭圆曲线，其中 p=17 显示相同的椭圆曲线在素数阶 17 的小得多的有限域上，显示网格上的点图案。 secp256k1 以太坊椭圆曲线可以被认为是在深不可测的大网格上的更复杂的点图案。

！[图2](https://github.com/JBossBC/ethereumbook-ch/blob/main/book/images/ec_over_small_prime_field.png?raw=true)

图 2. 椭圆曲线密码学：可视化 F(p) 上的椭圆曲线，其中 p=17
因此，例如，以下是坐标为 (x,y) 的点 Q，它是 secp256k1 曲线上的一个点：


> Q =
(49790390825249384486033144355916864607616083520101638681403973749255924539515,
59574132161899900045862086493921015780032175291755807399284007721050341297360)


示例1.展示了如何使用 Python 自行检查。变量 x 和 y 是点 Q 的坐标，如前例所示。变量 p 是椭圆曲线的素数阶（用于所有模运算的素数）。 Python的最后一行是椭圆曲线方程（Python中的%运算符就是取模运算符）。如果 x 和 y 确实是椭圆曲线上一点的坐标，那么它们满足方程并且结果为零（0L 是一个值为零的长整数）。通过在命令行中键入 **python** 并从列表中复制每一行（在提示符 >>> 之后），亲自尝试一下。


### 使用Python确认此点在椭圆曲线上

    Python 3.4.0 (default, Mar 30 2014, 19:23:13)
    [GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
    Type "help", "copyright", "credits" or "license" for more information.
    >>> p = 115792089237316195423570985008687907853269984665640564039457584007908834 \
    671663
    >>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
    >>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
    >>> (x ** 3 + 7 - y**2) % p
    0L


### 椭圆曲线算术运算

许多椭圆曲线数学看起来和工作起来都非常像我们在学校学到的整数算法。具体来说，我们可以定义一个加法运算符，它不是沿着数字线跳跃，而是跳跃到曲线上的其他点。一旦我们有了加法运算符，我们也可以定义一个点和一个整数的乘法，相当于重复加法。

椭圆曲线加法被定义为给定椭圆曲线上的两个点 P1 和 P2，在椭圆曲线上还有第三个点 P3 = P1 + P2。

在几何上，第三点 P3 是通过在 P1 和 P2 之间画一条线来计算的。这条线将在另外一个地方与椭圆曲线相交（令人惊讶）。将此点称为 P3' = (x, y)。然后反映在 x 轴上得到 P3 = (x, –y)。

如果 P1 和 P2 是同一点，则 P1 和 P2“之间”的线应延伸为该点 P1 处曲线的切线。该切线将恰好在一个新点与曲线相交。您可以使用微积分技术来确定切线的斜率。奇怪的是，即使我们将兴趣限制在具有两个整数坐标的曲线上的点上，这些技术仍然有效！

在椭圆曲线数学中，还有一个点叫做“无穷远点”，大致对应数字零的作用。在计算机上，它有时表示为 x = y = 0（不满足椭圆曲线方程，但这是一个可以检查的简单的单独情况）。有几个特殊情况可以解释无穷远点的必要性。

在某些情况下（例如，如果 P1 和 P2 具有相同的 x 值但不同的 y 值），该线将完全垂直，在这种情况下 P3 = 无穷远点。

如果 P1 是无穷远点，则 P1 + P2 = P2。同样，如果 P2 是无穷远点，则 P1 + P2 = P1。这显示了无穷远点如何扮演零在“正常”算术中扮演的角色。

事实证明 + 是结合性的，这意味着 (A + B) + C = A + (B + C)。这意味着我们可以毫无歧义地写出 A + B + C（没有括号）。

现在我们已经定义了加法，我们可以用扩展加法的标准方式定义乘法。对于椭圆曲线上的一点P，如果k是一个整数，那么k * P = P + P + P + … + P (k次)。请注意，在这种情况下，k 有时（可能令人困惑）称为“指数”。

### 生成公钥

从随机生成的数字 k 形式的私钥开始，我们将其乘以曲线上称为生成点 G 的预定点，以生成曲线上其他位置的另一个点，即相应的公钥 K：

K = k * G
生成点被指定为 secp256k1 标准的一部分；它对于 secp256k1 的所有实现都是相同的，并且从该曲线派生的所有密钥都使用相同的点 G。因为生成点对于所有以太坊用户始终相同，所以私钥 k 乘以 G 将始终产生相同的公钥密钥K。k和K之间的关系是固定的，但只能从一个方向计算，从k到K。这就是为什么以太坊地址（从K派生）可以与任何人共享并且不会泄露用户的私钥（ k).

正如我们在上一节中描述的，k * G 的乘法相当于重复加法，所以 G + G + G + … + G，重复 k 次。总之，为了从私钥 k 生成公钥 K，我们将生成点 G 与自身相加 k 次。

> 私钥可以转换为公钥，但公钥不能转换回私钥，因为数学只有一种方法。


让我们应用此计算来查找我们在私钥中向您展示的特定私钥的公钥：

私钥到公钥计算示例


     K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G

密码库可以帮助我们使用椭圆曲线乘法计算 K。生成的公钥 K 定义为点：

     K = (x, y)

得到

    x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
    y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0


在以太坊中，您可能会看到公钥表示为 130 个十六进制字符（65 字节）的序列化。这是从行业联盟高效密码术标准组 (SECG) 提出的标准序列化格式中采用的，记录在高效密码术标准 (SEC1) 中。该标准定义了四种可能的前缀，可用于识别椭圆曲线上的点，列在序列化 EC 公钥前缀中。


表 1. 序列化的 EC 公钥前缀

|Prefix|Meaning|Length|
|--|--|--|
|0x00|Point at infinity|1|
|0x04|Uncompressed point|65|
|0x02|Compressed point with even y|33|
|0x03|Compressed point with odd y|33|


以太坊只使用未压缩的公钥；因此唯一相关的前缀是 (hex) 04。序列化连接公钥的 x 和 y 坐标：

     04 + x-coordinate (32 bytes/64 hex) + y-coordinate (32 bytes/64 hex)

因此，我们前面计算的公钥被序列化为：
 
     046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0 \
     c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0

### 椭圆曲线库

在加密货币相关项目中使用了 secp256k1 椭圆曲线的几个实现：

+ [OpenSSL](https://www.openssl.org/)

OpenSSL 库提供了一套全面的加密原语，包括 secp256k1 的完整实现。例如，要导出公钥，可以使用函数 EC_POINT_mul。

+ [libsecp256k1](https://github.com/bitcoin-core/secp256k1)

Bitcoin Core 的 libsecp256k1 是 secp256k1 椭圆曲线和其他加密原语的 C 语言实现。它是从零开始编写的，用于取代比特币核心软件中的 OpenSSL，被认为在性能和安全性方面都非常出色。

## 密码哈希函数


整个以太坊都使用加密哈希函数。事实上，散列函数在几乎所有密码系统中都得到了广泛使用——密码学家 Bruce Schneier 发现了这一事实，他说，“单向散列函数不仅仅是加密算法，它是现代密码学的主力军。”

在本节中，我们将讨论哈希函数，探索它们的基本属性，并了解这些属性如何使它们在现代密码学的众多领域中如此有用。我们在这里讨论哈希函数，因为它们是将以太坊公钥转换为地址的一部分。它们还可用于创建数字指纹，这有助于验证数据。

简单来说，哈希函数是“可用于将任意大小的数据映射到固定大小的数据的任何函数”。哈希函数的输入称为原像、消息或简称为输入数据。输出称为散列。加密哈希函数是一个特殊的子类别，具有对保护平台（如以太坊）有用的特定属性。

加密散列函数是一种单向散列函数，可将任意大小的数据映射到固定大小的位串。 “单向”性质意味着如果只知道输出哈希，则重新创建输入数据在计算上是不可行的。确定可能输入的唯一方法是进行强力搜索，检查每个候选者的匹配输出；鉴于搜索空间几乎是无限的，很容易理解该任务实际上是不可能的。即使您找到了一些创建匹配散列的输入数据，它也可能不是原始输入数据：散列函数是“多对一”函数。查找散列为相同输出的两组输入数据称为查找散列冲突。粗略地说，哈希函数越好，哈希冲突就越少。对于以太坊，它们实际上是不可能的。

让我们仔细看看加密哈希函数的主要属性。这些包括：

+ 确定性

给定的输入消息总是产生相同的散列输出。

+ 可验证性

计算消息的哈希值是高效的（线性复杂度）

+ 不相关

对消息的微小更改（例如，1 位更改）应该会极大地改变散列输出，以至于它无法与原始消息的散列相关联。

+ 不可逆性

从其哈希计算消息是不可行的，相当于对所有可能的消息进行蛮力搜索。

+ 碰撞保护

计算产生相同哈希输出的两个不同消息应该是不可行的。


抵抗哈希冲突对于避免以太坊中的数字签名伪造尤为重要。

这些属性的组合使加密哈希函数可用于广泛的安全应用程序，包括：

+ 数据指纹
+ 消息完整性（错误检测）
+ 工作证明
+ 身份验证（密码散列和密钥扩展）
+ 伪随机数生成器
+ 消息承诺（commit-reveal 机制）
+ 唯一标识符



随着我们在系统的各个层中前进，我们会在以太坊中找到许多这样的东西。

### 以太坊的加密哈希函数：Keccak-256


以太坊在很多地方都使用了 Keccak-256 加密哈希函数。 Keccak-256 被设计为美国国家标准技术研究院 2007 年举办的 SHA-3 密码哈希函数竞赛的候选者。 Keccak 是获胜的算法，它在 2015 年被标准化为联邦信息处理标准 (FIPS) 202。

然而，在以太坊发展的时期，NIST 的标准化还没有最终确定下来。 NIST 在标准流程完成后调整了 Keccak 的一些参数，据称是为了提高其效率。与此同时，英勇的举报人爱德华斯诺登披露的文件暗示 NIST 可能受到国家安全局的不当影响，故意削弱 Dual_EC_DRBG 随机数生成器标准，有效地在标准随机数生成器中放置了后门。这场争论的结果是对所提议的更改的强烈反对以及 SHA-3 标准化的显着延迟。当时，以太坊基金会决定实施其发明者提出的原始 Keccak 算法，而不是 NIST 修改的 SHA-3 标准。

> 注意:虽然您可能会在整个以太坊文档和代码中看到提到“SHA-3”，但许多（如果不是全部）这些实例实际上是指 Keccak-256，而不是最终确定的 FIPS-202 SHA-3 标准。

### 如何判断使用的是哪种哈希(keccak256还是sha3)

如果两者都称为“SHA-3”，您如何判断您正在使用的软件库是否实现了 FIPS-202 SHA-3 或 Keccak-256？

一种简单的判断方法是使用测试向量，即给定输入的预期输出。最常用于哈希函数的测试是空输入。如果您使用空字符串作为输入运行哈希函数，您应该会看到以下结果：

      Keccak256("") =
      c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

      SHA3("") =
      a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a

无论调用什么函数，您都可以通过运行这个简单的测试来测试它是原始的 Keccak-256 还是最终的 NIST 标准 FIPS-202 SHA-3。请记住，以太坊使用 Keccak-256，尽管它在代码中通常被称为 SHA-3。

> 提示: 由于以太坊 (Keccak-256) 和最终标准 (FIP-202 SHA-3) 中使用的哈希函数之间的差异造成的混淆，目前正在努力重命名所有代码、操作码、和库到 keccak256。有关详细信息，请参阅 EIP-59。

## 以太坊地址

以太坊地址是使用 Keccak-256 单向哈希函数从公钥或合约派生的唯一标识符。

在我们之前的示例中，我们从私钥开始，并使用椭圆曲线乘法导出公钥：

私钥k：


     k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315

公钥 K（x 和 y 坐标串联并显示为十六进制）：

     K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e...


> 注意:值得注意的是，在计算地址时，公钥没有使用前缀（十六进制）04 进行格式化。

我们使用 Keccak-256 来计算这个公钥的哈希值

     Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9


然后我们只保留最后 20 个字节（最低有效字节），这是我们的以太坊地址：

    001d3f1ef827552ae1114027bd3ecf1f086ba0f9


大多数情况下，您会看到带有前缀 0x 的以太坊地址，表明它们是十六进制编码的，如下所示：
   
    0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9



### 以太坊地址格式化


以太坊地址是十六进制数字，是从公钥的 Keccak-256 散列的最后 20 个字节派生的标识符。

与比特币地址不同，比特币地址在所有客户端的用户界面中进行编码以包含内置校验和以防止输入错误的地址，以太坊地址以原始十六进制形式呈现，没有任何校验和。

该决定背后的基本原理是，以太坊地址最终将隐藏在系统较高层的抽象（例如名称服务）之后，并且如有必要，应在较高层添加校验和。

实际上，这些更高层的开发速度太慢，这种设计选择在生态系统的早期导致了许多问题，包括由于地址输入错误和输入验证错误导致的资金损失。此外，由于以太坊名称服务的开发速度比最初预期的要慢，因此钱包开发人员采用替代编码的速度非常缓慢。接下来我们将看看一些编码选项。


### Inter Exchange 客户端地址协议


Inter exchange Client Address Protocol (ICAP) 是一种以太坊地址编码，与国际银行帐号 (IBAN) 编码部分兼容，为以太坊地址提供通用、校验和和可互操作的编码。 ICAP 地址可以对以太坊地址或在以太坊名称注册处注册的通用名称进行编码。您可以在 Ethereum Wiki 上阅读更多关于 ICAP 的信息。

IBAN 是识别银行帐号的国际标准，主要用于电汇。它在欧洲单一欧元支付区 (SEPA) 及其他地区得到广泛采用。 IBAN 是一项集中且​​受到严格监管的服务。 ICAP 是一个分散但兼容的以太坊地址实现。

IBAN 由最多 34 个字母数字字符（不区分大小写）的字符串组成，包括国家代码、校验和和银行账户标识符（特定国家/地区）。

ICAP 通过引入非标准国家代码“XE”（代表“以太坊”）使用相同的结构，后跟两个字符的校验和和帐户标识符的三种可能变体：

+ direct

一个大端 base-36 整数，最多包含 30 个字母数字字符，代表以太坊地址的 155 个最低有效位。由于此编码适合不到通用以太坊地址的完整 160 位，因此它仅适用于以一个或多个零字节开头的以太坊地址。优点是在字段长度和校验和方面与 IBAN 兼容。示例：XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD（33 个字符长）。

+ basic


与 Direct 编码相同，只是它的长度为 31 个字符。这允许它对任何以太坊地址进行编码，但使其与 IBAN 字段验证不兼容。示例：XE18CHDJBPLTBCJ03FE9O2NS0BPOJVQCU2P（35 个字符长）。


+ indirect

对通过名称注册提供商解析为以太坊地址的标识符进行编码。它使用 16 个字母数字字符，包括资产标识符（例如 ETH）、名称服务（例如 XREG）和 9 个字符的人类可读名称（例如 KITTYCATS）。示例：XE##ETHXREGKITTYCATS（20 个字符长），其中 ## 应替换为两个计算的校验和字符。


我们可以使用 helpeth 命令行工具来创建 ICAP 地址。您可以通过以下方式安装它来获得帮助：



       $ npm install -g helpeth


如果您没有 npm，您可能必须先安装 nodeJS，您可以按照 [https://nodeJS.org](https://nodeJS.org) 上的说明进行安装。

现在我们有了 helpeth，让我们尝试使用我们的示例私钥（以 0x 为前缀并作为参数传递给 helpeth）创建一个 ICAP 地址。



      $ helpeth keyDetails \
     -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315

     Address: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
     ICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D
     Public key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b...


helpeth 命令为我们构造了一个十六进制的以太坊地址和一个 ICAP 地址。我们的示例密钥的 ICAP 地址是：

> XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD


因为我们的示例以太坊地址恰好以零字节开头，所以可以使用在 IBAN 格式中有效的直接 ICAP 编码方法对其进行编码。您可以分辨出来，因为它有 33 个字符长。

> 提醒:任何以太坊地址以零字节开头的概率为 256 分之一。要生成这样的地址，平均需要使用 256 个不同的随机私钥进行 256 次尝试，然后才能找到一个与 IBAN 兼容的“direct”编码的私钥ICAP 地址。


不幸的是，目前只有少数钱包支持 ICAP。

### 大写校验和的十六进制编码 (EIP-55)


由于 ICAP 和名称服务的部署缓慢，以太坊改进提案 55 (EIP-55) 提出了一个标准。 EIP-55 通过修改十六进制地址的大小写，为以太坊地址提供向后兼容的校验和。这个想法是以太坊地址不区分大小写，所有钱包都应该接受以大写或小写字符表示的以太坊地址，在解释上没有任何差异。

通过修改地址中字母字符的大小写，我们可以传达一个校验和，该校验和可用于保护地址的完整性，防止输入或读取错误。不支持 EIP-55 校验和的钱包会简单地忽略地址包含混合大小写的事实，但支持它的钱包可以验证它并以 99.986% 的准确率检测错误。

混合大写编码很微妙，您一开始可能没有注意到。我们的示例地址是：


     0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9


使用 EIP-55 混合大小写校验和变为：

     0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9


你能说出区别吗？十六进制编码字母表中的一些字母 (A–F) 字符现在是大写字母，而其他则是小写字母。

EIP-55 实现起来非常简单。我们采用小写十六进制地址的 Keccak-256 哈希。这个散列充当地址的数字指纹，为我们提供方便的校验和。输入（地址）的任何小变化都会导致结果哈希（校验和）发生大变化，从而使我们能够有效地检测错误。然后我们地址的散列被编码为地址本身的大写。让我们一步一步地分解它：

1. 哈希小写地址，不带 0x 前缀：
   
     Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") =
      23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1

2. 如果散列的相应十六进制数字大于或等于 0x8，则将每个字母地址字符大写。如果我们将地址和散列排列起来，这会更容易显示：

    Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
    Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...


我们的地址在第四个位置包含一个字母字符 d。散列的第四个字符是 6，小于 8。因此，我们将 d 保留为小写。我们地址中的下一个字母字符是 f，在第六个位置。十六进制散列的第6个字符是c，大于8。因此，我们将地址中的F大写，以此类推。如您所见，我们仅使用哈希的前 20 个字节（40 个十六进制字符）作为校验和，因为我们在地址中只有 20 个字节（40 个十六进制字符）可以适当地大写。

自己检查生成的混合大写地址，看看你是否能分辨出哪些字符是大写的，以及它们对应于地址哈希中的哪些字符：


    Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
    Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...



### 检测 EIP-55 编码地址中的错误

现在，让我们看看 EIP-55 地址将如何帮助我们发现错误。假设我们已经打印出一个 EIP-55 编码的以太坊地址：

    0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9

现在让我们在阅读该地址时犯一个基本错误。最后一个之前的字符是大写字母 F。在这个例子中，假设我们误读为大写字母 E，并在我们的钱包中输入以下（错误的）地址：

    0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9

幸运的是，我们的钱包符合 EIP-55 标准！它注意到混合大小写并尝试验证地址。它将其转换为小写，并计算校验和哈希：


    Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9") =
    5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927

正如您所看到的，即使地址只改变了一个字符（实际上，只有一位，因为 e 和 f 相差一位），地址的哈希值已经发生了根本性的变化。这就是散列函数的特性，使它们对校验和非常有用！

    001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
    5429b5d9460122fb4b11af9cb88b7bb76d892886...


都错了！几个字母字符的大写不正确。请记住，大写是正确校验和的编码。

我们输入的地址大小写与刚刚计算的校验和不匹配，这意味着地址中发生了一些变化，并且引入了错误。

## 总结


在本章中，我们简要介绍了公钥密码学，重点介绍了以太坊中公钥和私钥的使用，以及哈希函数等加密工具在创建和验证以太坊地址时的使用。我们还研究了数字签名以及它们如何在不泄露私钥的情况下证明私钥的所有权。在 [钱包章节] 中，我们将把这些想法放在一起，看看如何使用钱包来管理密钥集合。